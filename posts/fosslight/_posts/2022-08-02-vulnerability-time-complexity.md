---
layout: post
title: "취약점 도메인 쿼리 튜닝 연구"
tags: [Java]
comments: true
---


## Vulnerability 리스트를 가져올때 호출되는 mybatis Mapper

```java
public HashMap<String, Object> getVulnerabilityList(Vulnerability vulnerability, boolean exportFlag) {
		...
		...
		int records = vulnerabilityMapper.selectVulnerabilityTotalCount(vulnerability);
		vulnerability.setTotListSize(records);

		List<Vulnerability> list = null;
		if(exportFlag) {
			list = vulnerabilityMapper.selectVulnerabilityExportList(vulnerability);
		}else {
			list = vulnerabilityMapper.selectVulnerabilityList(vulnerability);
		}

		map.put("page", vulnerability.getCurPage());
		map.put("total", vulnerability.getTotBlockSize());
		map.put("records", records);
		map.put("rows", list);
		return map;
	}
```

`vulnerabilityMapper.selectVulnerabilityTotalCount` : 취약점의 갯수를 셉니다.

`vulnerabilityMapper.selectVulnerabilityList` : 취약점의 리스트를 가져옵니다.

## 병목이 일어나는 지점들

### `vulnerabilityMapper.selectVulnerabilityList`

![2021_12_28 18_07 Office Lens.jpg](/imgs/fosslight/2022-08-02-vulnerability-time-complexity/1.png)

빨간색 → 주황색 → 연두색 → 하늘색 → 검은색 으로 실행됩니다.

여기서 정렬을 진행하고, 페이지를 가져오는 검정색 (limitpage) 블록을 맨마지막에 실행하는것 문제가 될수 있다고 생각합니다.

연두색 블록에서 `NVD_DATA_SCORE_V3` 와 `OSS_NICKNAME`과의 join을 통해 select를 진행하게 되는데, 한페이지의 데이터의 갯수는 15, 30, 50 개 임에도 불구하고 `NVD_DATA_SCORE_V3` 전체 튜플 대상으로 `OSS_NICKNAME` 와 함께 서브쿼리가 진행됩니다.

`NVD_DATA_SCORE_V3` 튜플의 갯수를 N,  `OSS_NICKNAME` 튜플의 갯수를 M 이라고 하면 연산시 최악의 시간복잡도는 `O(N*M)` 이 됩니다. 

`NVD_DATA_SCORE_V3` 는 특성상 데이터의 수가 많으므로, `OSS_NICKNAME`의 튜플수가 많아지게 되면 응답시간은 매우 크게 증가할수 있습니다.

## 생각해본 해결책들

### 첫번째 방법

`vulnerabilityMapper.selectVulnerabilityList`

- 페이지의 행갯수만큼만 우선 `NVD_DATA_SCORE_V3` 에서 가져옵니다.
- 페이지에 대해서만 OSS_NICKNAME과 서브쿼리 을 하도록 구현합니다.
- O(N*M) 에서 N의 크기를 페이지의 크기(15, 30, 50) 만큼 줄일수 있습니다.

로딩시간을 강력하게 줄일수 있지만, oss_nickname을 사용한 정렬기능을 사용할수 없는 단점이 있습니다.

### 두번째 방법

`인덱스 생성`

```sql
CREATE INDEX oss_name_index ON oss_nickname ( OSS_NAME );
CREATE INDEX oss_nickname_index ON oss_nickname ( OSS_NICKNAME );
```

select시 서브쿼리에 사용되는 `OSS_NICKNAME` 테이블의 두컬럼인 `OSS_NAME`, `OSS_NICKNAME` 에 index를 생성합니다. 조건검사시 `OSS_NICKNAME` 을 풀스캔하지 않아도 되므로, O(N*M) 에서 M의 값을 줄일수 있습니다.

기존의 코드를 최대한 지킬수 있고, 적용이 빠릅니다. 인덱스 생성만으로 시간을 40% 줄일수 있었으며, 집계쿼리까지 수정하면 약 70%의 시간을 줄일수 있었습니다.

OSS 신규 생성시 인덱스에 데이터 추가를 위한 작업이 추가로 진행될수 있는 단점이 있고, selectivity가 높으면 좋은 방법이 아닐수 있습니다.

## 비교
![2021_12_28 18_07 Office Lens.jpg](/imgs/fosslight/2022-08-02-vulnerability-time-complexity/2.png)
