---
layout: post
title: "서버 개론"
# author: "DONGWON KIM"
# meta: "Springfield"
tags: [infra]
comments: true
---

## 서버와 일반 컴퓨터의 차이

- 서버는 보안을 위해 반드시 필요한 파일(MINIMAL)만 설치
- SLA을 지키도록 더 내구성있고 성능이 좋으며 이중화 구성이 권장됨

## 서버의 형태에 따른 분류

- 렉 마운트
    - 1U(엔트리, 저렴), 2U, U는 높이를 의미한다.
    - X86, Arm
    - 리눅스가 주로 탑재
    - 렉 마운트형 서버는 탑재를 위한 레일 호환이 되는지 체크, 안되면 호환 선반 필요
- 타워형 서버
    - 주로 유닉스가 장착
    - RISC

## 용도에 따른 분류

- 엔트리, 미들레인지, 하이엔드
- 엔터프라이즈 서버
    - 기간계(회사의 인사관리, 재고관리 등등..) 핵심 서버
    - 시스템 이상시 자동통보되어 대응하는 서비스

## 서버 사양의 결정

온프레미스에서는 임시로 결정한 서버 사양의 기기를 현장에 투입후, 하드웨어 자원의 이용상황을 측정후 결정, 클라우드에 비해 더 많은 노력과 시간이 필요하다.

## 서버의 확장

### 스케일아웃

서버의 수를 늘리는 방법, 로드밸런서가 필요할수 있고 주로 웹어플리케이션 환경에 유리하다.

클라우드에서는 오토스케일링 그룹을 통해 서버를 늘릴수 있다.

### 스케일 업

고성능의 부품으로 교체하는 방식, 분산 아키텍처가 어려운 데이터베이스에 사용한다. 

클라우드에서는 데이터베이스의 인스턴스 타입을 올리거나, 메모리를 증가시키는 패턴이 있다.

## CPU

이전에는 주파수를 올리는 방식으로 성능향상을 기대했지만, 발열문제로 멀티코어로 방향을 잡는 추세이다.

전력량 대비 성능 향상을 위해 arm 코어의 도입을 시도할수 있지만, 어플리케이션 호환성, 컴파일 문제를 해결해야한다.

소켓(물리적인 CPU 갯수)*코어수(CPU안의 코어)*스레드수(코어에서 동시에 처리하는 연산수) 가 성능의 지표가 된다.

캐시 용량 (L1, L2)이 높아지면 가격이 올라간다. 하이퍼쓰레딩을 통해 하나의 코어로 병렬처리를 하는 스펙도 있다.

사용할 소프트웨어의 라이센스 체계도 고려한다.(소켓당 단가가 발생한다.) 

클라우드에선 대부분의 회사들의 인스턴스가 같은 서버에서 돌아갈 가능성이 높은데 이를 멀티 테넌시라고 한다. 만약 보안 요구사항 혹은 소프트웨어의 라이센스가 있는 경우 하드웨어를 렌탈(베어메탈) 하는 인스턴스도 있다.

## 메모리

메모리의 성능은 채널(cpu와 메모리사이에 입출력 하는 통로), 랭크(통로를 통해 통신하는 bit수), 뱅크(채널당 꽂을수 있는 메모리의 숫자)에 따라 달라진다.

ECC 메모리는 비트 반전 오류 발생시, 자동으로 보정하는 유형이다.

각 프로세서의 메모리 구성은 같아야 하며, ECC와 논ECC는 섞어 쓸수 없다.

## 디스크

### 분류

- ATA(IDE): 병렬 방식(하나의 대역폭을 여러 하드디스크가 공유하는 방식), 여러 디스크 사용시 성능저하의 문제가 있다.
- Serial(SCSI): 하나의 대역에 하나의 디스크, 성능이 좋으나 비싸다
    - ISCSI: DAS를 통해 직접 연결해도되지만, 네트워크를 통해 디스크를 서버(컴퓨터)에 제공, 클라우드 환경에서 볼륨을 지원하기 위해 많이 사용한다.
    - 어플리케이션 서버 - 스위치 - 디스크서버 - 디스크 로 구성한다.
- FC(Fibre channel) 하드디스크: 초고속, SAN 스토리지에 유리하다.
    - 어플리케이션 서버 -fc- SAN전용스위치 -fc- 디스크 로 구성되어 더 빠르다.

### HDD, SSD

hdd는 순차적인 탐색(데이터분석, 대량의 데이터를 한번에 입/출력)이나 백업에 유리하다.

SSD는 시간당 요청횟수가 많고, 랜덤 탐색에 유리하다. (DB, 어플리케이션)

### RAID (Redundent Array of inexpensive/independent disk)

성능과 내장애성을 높이고 디스크 비용절약을 목적으로 사용된다. LVM 이나 raid software로 RAID를 구성할수 있다.

- RAID 0
    - Concateuate: 스토리지를 묶어서 용량이 많은 디스크부터(잘못된 설며일수 있음) 순차적으로 쓰자(용량)
    - Stripe: 파일을 stripe unit size로 쪼개어 스토리지들에 병렬에 쓰는 방식(용량, 최고성능, 안정성저하)
- RAID 1 (mirroring): 디스크를 이중화한다. 가장 고비용이면서 안정적인 방식
- RAID 3, 4, **5**
    - 최소 3개이상의 디스크가 필요하고 패리티를 사용하여 내구성을 지킨다.
    - ex) 홀수패리티방식, 디스크1: 1, 디스크2: 0, 패리티디스크: 0, 만약 디스크2 가 날라가도, 비트1의 갯수가 홀수인지를 체크하여 디스크2: 0을 복구 할수 있다.
    - 패리티디스크가 1개라면(RAID 3, 4), 데이터 갱신추가시, 항상 패리티티스크는 새로운 패리티를 쓰기위해 부하가 발생하므로, 최근에는 디스크들 사이에 패리티를 분산시키는 RAID 5를 많이 사용한다.
    - 한개의 디스크가 나갔을때 동작을 보장한다. 따라서 디스크의 갯수가 많아질수록 패리티전략은 불리해진다.
- RAID 6
    - 페리티를 분산하여 두개의 디스크에  작성하는 방식
    - 최소 6개가 필요하며 구현이 복잡하고 응답속도가 느리다.
    - 두개의 디스크가 나가도 서비스의 동작을 보장한다.
- **RAID 10 (스토리지 가격이 저하되어 많이 사용)**
    - strip and mirror
    - 최소 디스크의 갯수가 4개가 필요하다.
    - 디스크의 숫자가 늘어나더라도 장애 발생시 복구시간이 일정하다.
- RAID 01
    - mirror and strip
    - 최소 디스크의 갯수가 4개가 필요하다.
    - 디스크의 숫자가 늘어날수록 장애 발생시 복구시간이 늘어난다.
