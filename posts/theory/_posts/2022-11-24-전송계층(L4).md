---
layout: post
title: "전송계층(L4)"
tags: [network]
comments: true
---

## 개요

- 프로세스와 프로세스간의 통신을 담당하는 계층

## TCP

- 전송제어 프로토콜
- 어떻게 제어하는가?
    - 흐름제어, 오류제어, 혼잡제어를 한다.
- 왜 전송제어를 하는가
    - 신뢰성(순서대로 반드시) 있게 세그먼트를 전달시키기 위해서이다.
- 보통 통신은 단방향이 아니라 양방향으로 이루어지기때문에 하나의 패킷에 순서번호, 확인응답번호, 패킷을 모두 포함하여 효율성을 올린다. (피기배깅)
- TCP 패킷에는 프로세스의 포트정보, 순서번호, 확인응답번호, 체크섬, Flag 등이 있다.

### 순서 번호

- 프레임 별로 부여되는 일련의 번호
- 왜 부여되는가
    - 한번에 모든데이터를 전송시키기 힘드므로 나누어서 순서번호를 부여한후 순서대로 전송한다.
- 순서 번호의 최댓값이 송신 윈도우 크기보다 커야 한다.
    - 순서 번호를 지정할 때 최댓값 이후에 다시 0번으로 순서 번호를 지정하기 때문에 송신 윈도우의 크기가 더 클 경우 순서 번호가 겹치는 현상이 발생할수 있기 때문이다.

### 흐름제어

- 수신자의 패킷 처리 속도에 맞추는것이다.
- 수신측에서 서버에 피드백을 해줘서 (세그먼트에 담아서) 속도를 조절한다.
    - 패킷에 현재 윈도우에 남은 사이즈에 대한정보를 같이 전달한다.
- 정지 대기 기법
    - 매번 전송한 패킷에 대한 확인응답을 받아야지만 다음 패킷을 전송한다.
- 슬라이딩 윈도우
    - 수신측에서 설정해준 동적인 윈도우 크기만큼 송신측에서 확인응답 없이 전송히여 흐름제어
    - modulo 연산을 활용하기 때문에 원형으로 표현이 가능

### 오류제어

- 오류를 판단하는 기준
    - 송수신측에서 프레임이 손상되었거나(NACK) 손실되었을때(timeout) 오류임을 확인하고 다시 해당 순서번호 요청 한다. (ARG)
- **Stop and Wait ARQ**
    - 하나씩 보내고 , 하나씩 까보면서 에러를 확인한다.
    - 느리다.
- **Go back N ARQ**
    - 수신측에서는 가장 최근에 받은 순서번호 다음번호만 받는다.
        - 만약 다른 순서번호가 오면 drop하고 다음번호에 대한 ACK를 보낸다.
    - 송신측에서는 시간이 지나도 수신측으로 응답이 없다면 타임아웃 확인된 마지막 프레임 이후로 모든 프레임을 전송한다.
    - 수신윈도우의 크기는 1
- **SR(Selective-Reject) ARQ**
    - 일단 수신측에 순서가 안맞더라도 버퍼에 저장한후 ACK를 보낸다.  (재전송한 데이터때문에 프레임의 순서가 안맞을수 있기 때문에 버퍼를 둔다)
    - 송신측에서는 모든 TCP 세그먼트에 대해 타이머를 걸어, timeout된 친구들을 재전송한다.
    - SR은 window size가 sequence number의 개수의 절반보다 이하여야한다.
        - 왜냐하면 window는 원형큐이므로, 윈도우를 갱신하다면 첫번째 순서번호로 돌아올수 있다!
        - 그렇게 되면 이 순서번호가 옛날에 받았던것인지 새로운것인지 구분못한다.
        - 수신윈도우가 0 1 2 **3 0 1 2** 상황에서 0인 패킷이 왔다가 해보자
        - 왜냐하면 go back N의 경우 순서대로 쌓기 때문에 문제가 없지만 (수신윈도우 사이즈:1)
        - SR은 수신윈도우에 0을 인식하므로 이 0이 옜날 0인지 지금 0인지 알수 없다.
        - **window size <= (sequence number)/2 보다 작게 가져가면 문제가 안발생한다.**

### 혼잡제어

- 송신쪽에서 네트워크 환경을 고려해서 속도를 조절하는것
    - 이를 위해 혼잡윈도우를 송신위도우와 별도로 관리를 한다.
- tahoe
    - slow-start(배수로 증가시키다가 혼잡시 1로 줄인다)와 threshold부터 AIMD(합증가 곱감소)방식을 사용한다.
    - 혼잡상황 (3 duplicated ack, timeout) 이 되면 빠른회복을 한다. 혼잡상황 발생한 데이터를 기반으로 threshold를 설정한다.
    - 3 duplicated ack 의 경우 timeout과 상관없이 패킷을 재전송 하는데 (빠른 재전송)
- reno
    - **`3 ACK Duplicated`**와 **`Timeout`**을 구분한다.
    - **`3 ACK Duplicated` 발생시 반타작 낸후 AIMD로 처리하는데 이를 빠른 회복 기법이라 한다.**

### 체크섬

- TCP 패킷의 오류를 감지 하기 위해 checksum을 사용한다.
- 체크섬 생성과정
    - psuedo header 생성 (source, dest, TCP+header+payload 바이트수, 프로토콜)
    - 16비트로 쪼개서 다 더한다. 도중에 캐리가 발생하면 모두 다시 1의 자리에서 더해준다.
    - 1의 보수를 취하면 완성
- 헤더의 체크섬과 새로 계산된 체크섬이 다르면 재전송 요청

### 3 way handshake

- 클라이언트는 첫 번째 세그먼트로 SYN 플래그가 1로 설정되어있고 임의의 값을 순서번호 n으로 설정한 SYN 세그먼트를 전송한다.  SYN_SENT 상태
- 서버가 SYN 을 수신후 Listen에서 SYN_RCVD 상태로 전환된다.
- 서버는 두번째 세그먼트로서 SYN+ACK 플래그가 1로 설정되어있고 임의의 값 m 순서번호로 설정하고 ACK 순서번호를 n+1로 세그먼트를 전송한다.
- 클라이언트는 ESTABLISHED 상태로 전환 ACK  순서번호 m+1 세그먼트 서버로 전송
- 서버는  ESTABLISHED 상태로 전환

### 4 way handshake

1. 클라이언트가 연결을 종료하겠다는 FIN Flag를 전송한다.
2. 서버에서는 FIN 패킷을 정상적으로 받았다는 ACK를 클라이언트에 전송해준다. 그 후 서버는 CLOSE-WAIT 상태로 빠져든다.
3. 연결을 종료한 후 서버는 클라이언트에게 FIN Flag를 전송해준다.
4. 서버로부터 전송된 FIN Flag를 받은 클라이언트는 확인을 알리는 ACK를 서버로 전송한 후, 일정 시간동안 TIME-WAIT 상태에 빠지게 된다.
5. 클라이언트로 부터 ACK를 받은 서버는 소켓을 Close하고 두 TCP간의 세션이 종료된다.
6. TIME-WAIT에 빠진 클라이언트는 서버로 부터 FIN을 수신하더라도, 일정시간동안 세션을 유지하며 도착하지 않은 패킷을 기다린다.

## UDP

- 비연결형 비신뢰성 전송계층 프로토콜 이다.
- 8비트의 고정헤더로 구성되어있다. 흐름제어, 오류제어, 혼잡제어 기능을 제공하지 않으며 여러 프로세스를 하나의 UDP가 서비스할수 없다. DNS나 스트리밍 구축시 많이 사용한다. UDP에서 패킷은 데이타그램 이라고 부른다.