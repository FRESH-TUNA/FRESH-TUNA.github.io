---
layout: post
title: "파이프와 리다이렉션"
tags: [OS]
comments: true
---

## 스트림
스트림(Stream)은 시간이 경과하며 쌓인 연속적인 데이터를 의미한다.

## 파일 디스크립터
파일 디스크립터(File Descriptor)는 운영 체제에서 파일이나 소켓, 파이프, 스트림 등의 입출력 장치에 접근하기 위한 추상화된 인터페이스입니다. 파일 디스크립터는 각각의 열린 파일이나 입출력 장치에 할당되며, 프로세스가 파일이나 장치와 상호 작용하기 위한 핸들 역할을 합니다.

일반적으로 파일 디스크립터는 정수로 나타내며, 각 파일 디스크립터에는 해당 파일이나 장치에 대한 정보가 연결되어 있습니다. 프로세스가 파일을 열거나 생성하면 운영 체제는 해당 파일에 대한 새로운 파일 디스크립터를 생성하고, 이 디스크립터를 통해 파일에 접근할 수 있습니다.

각각의 프로세스 마다 파일 디스크립터 0, 1, 2는 각각 표준입력 스트림, 표준출력 스트림, 표준에러 스트림에 접근하도록 예약되어있습니다.

## 파이프
파이프(pipe)는 프로세스 간 통신(Inter-Process Communication, IPC)을 위한 간단하면서도 효과적인 메커니즘 중 하나입니다. 파이프는 일방향 통신을 지원하며, 보통 부모 프로세스와 자식 프로세스 사이의 통신에 사용됩니다.

파이프는 주로 pipe() 시스템 콜을 사용하여 생성됩니다. 이 함수는 두 개의 파일 디스크립터를 반환하며, 하나는 읽기용(fd[0]), 다른 하나는 쓰기용(fd[1])입니다.

### 파이프 시스템콜 예제
```c
/**
 * 파이프 예시 코드
 * 
 * 현재의 코드에서는 부모 프로세스가 먼저 실행되는 것을 가정하고 있습니다. 만약 자식 프로세스가 부모 프로세스보다 먼저 실행된다면, 부모 프로세스가 파이프에 데이터를 쓰기 전에 자식 프로세스가 파이프를 읽으려고 할 수 있습니다. 이로 인해 자식 프로세스는 파이프에서 데이터를 읽을 수 없게 되며, 결과적으로 블로킹이 발생할 수 있습니다.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int pipe_fd[2];  // 파일 디스크립터 배열
    char buffer[50];

    // 파이프 생성
    if (pipe(pipe_fd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // 자식 프로세스 생성
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {  // 자식 프로세스
        close(pipe_fd[1]);  // 쓰기용 파이프 닫기
        read(pipe_fd[0], buffer, sizeof(buffer));
        printf("자식 프로세스에서 받은 메시지: %s\n", buffer);
        close(pipe_fd[0]);  // 읽기용 파이프 닫기
    } else {  // 부모 프로세스
        close(pipe_fd[0]);  // 읽기용 파이프 닫기
        write(pipe_fd[1], "안녕, 자식 프로세스!", 20);
        close(pipe_fd[1]);  // 쓰기용 파이프 닫기
    }

    return 0;
}
```

### 파이프 쉘 예제

## 리다이렉션
