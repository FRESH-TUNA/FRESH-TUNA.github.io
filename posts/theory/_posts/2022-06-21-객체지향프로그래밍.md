---
layout: post
title: "객체지향 프로그래밍"
tags: [Java, Spring]
comments: true
---
## 0. 객체지향 프로그래밍
- 우리가 사는 세계를 참고하여 역활과 역활에 따른 책임을 수행하는 객체를 만들고 그 객체들 간의 협력을 통해 로직을 구성하는 프로그래밍 방법이다.
- 객체는 상태를 가지고 있다. 현재 상태 기반으로 책임에 맞는 행동(메소드)를 수행하여 성공/실패여부를 판단하고, 새로운 상태로 갱신한다.

## 1. 객체지향 프로그래밍의 장단점
- 코드 재사용
    + 같은 역활이 필요하면, 해당 역활을 수행하는 객체를 재사용하면 된다.

- 유지보수가 쉽다
    + 문제가 있는 객체를 수정하면 된다.

- 처리속도가 느리다.
    + 객체간의 메시지 교환을 통해 처리하기 때문이다.

## 1. 객체지향 프로그래밍의 특징
#### 1. 추상화
복잡한 대상들에서 핵심적인 특징들을 찾아내 역활(개념)들로 분류하는것이다. 추상화에 단점은 없을까? 초기에 개발시간이 많이 걸리는 단점이 있다. (인터페이스 파일도 만들어야 되고, 디버깅할때 인터페이스 한번보고 클래스파일 찾아본다.)

#### 2. 캡슐화
메시지(요청)는 공개하고 메시지를 처리하는 메소드에 필요한 상태들을 감춘다. 상태에 대한 변경은 오르지 상태의 소유자 객체만 할수 있고 이를 통해 자율성을 얻는다. 자율성이 높아질수록 객체는 똑똑해지고 객체의 교체가 용이해지면서 유지보수가 쉬워진다.

#### 2. 다형성
- 메시지(요청)와 메소드(요청의 처리)를 분리한다.
- 클라이언트는 역활(인터페이스)에만 의존한다.
- 구현이 변경되더라도 클라이언트는 영향을 받지 않으므로 유지보수에 유리하다.


## 2. SOLID (객체지향의 원칙)
#### 1. SRP: 단일 책임 원칙
한클래스나 클래스의 함수는 하나의 책임을 가져야 한다. 다음 예시는 알고리즘에 대한 API를 제공하는 컨트롤러이다.
```java
@RestController
@RequiredArgsConstructor
@RequestMapping("/algorithms")
public class AlgorithmsController {
    private final AlgorithmsService algorithmsService;
    private final EntityManager em;

    @GetMapping
    public List<AlgorithmResponse> findAll() {
        QAlgorithm algorithm = QAlgorithm.algorithm;
        List<Algorithm> algorithms = return queryFactory
                .select(algorithm)
                .from(algorithm)

        List<AlgorithmResponse> responses = 
            algorithms.stream.map(a -> new AlgorithmResponse(a.name).toCollect());
            
        return responses;
    }
}
```

findAll() 메소드는 저장된 알고리즘들에 대한 정보를 반환한다. querydsl을 사용하여 잘 읽어오는것으로 보이지만
문제가 있습니다. 만약 기존의 jpql 방식으로 바꾸거나 아니면 더 좋은 라이브러리를 사용하면 어떨까. 또는 알고리즘에 
새로운 필드가 추가되면 어떨까.

컨트롤러의 코드를 바꾸는것에 그치지 않는다. 알고리즘과 관련된 정보를 또 다른 메소드에서 읽어서 쓰게 된다면 그 메소드의 
코드까지 수정이 발생하고, 수정이 많아질수록 부하가 걸리고 버그의 가능성이 높아진다.
위에 작성한 컨트롤러는 데이터를 DB에서 읽어오는것, 읽어온 알고리즘들을 responsedto로 변환하는 책임등 여러 책임을 가지고 있기
때문에 단일책임원칙을 위배한다. 

#### 2. OCP: 개방 패쇄 원칙
확장에는 열려있으나 변경에는 닫혀야 한다.
    - 캡슐화를 안하면, 결합도가 높아져 수정시 관련 클라이언트코드를 모두 수정해야 한다.
    - 캡슐화를 하면, 결합도가 낮아져 해당 객체의 메소드만 수정하면 되서 확장에 열려 있다.

```java
public interface QuestionSearchRepository<T, ID> {
    Page<Question> findAll(Pageable pageable, UserIdentityField user, QuestionParams params);
}
```

위 코드는 문제들을 DB로부터 읽어오는 레파지토리 계층의 메소드이다. 메소드를 JPQL로 구현한 구현체를 사용하고 있다고 가정해보자.
Querydsl이라는 새로운 라이브러리를 알게되었다. 하지만 걱정이 없다. 리파지토리를 사용하는 서비스는 인터페이스에만 의존하고 있기
때문에 Querydsl을 사용하여 새로운 구현체를 구현하더라도(확장에 열림) 인터페이스에만 맞춰서 구현하연 서비스 코드의 변경을 막을수 있다. (변경에는 닫힘)



#### 3. LSP: 리스코프 치환원칙
역활을 구현할때 역활에 맞게 구현해야 한다.

```java
public interface QuestionSearchRepository<T, ID> {
    Page<Question> findAll(Pageable pageable, UserIdentityField user, QuestionParams params);
}
```

이코드를 다시 가져왔다. 위 메소드는 검색메소드이기 때문에 구현체에서 검색기능을 구현해야 한다. 이메소드가 삭제나 생성, 업데이트를
하도록 구현하면 LSP를 위반하게 된다.

#### 4. ISP: 인터페이스 분리 원칙
되로록 인터페이스들을 분리하여(역활을 쪼개어) 컴포지션하자. 인터페이스를 최대한 쪼개놓고, 인터페이스가 변경되면, 이를 구현한 구현체들의 소스 변경을 최소화할수 있다. 만약 안지키면? 클래스 구현시 필요없는 기능도 구현할수 있다.
모뎀 클래스를 예로 들어보자, 모뎀은 데이터 통신에 관한 책임과 전화를걸고, 전화를 받는 연결관리에 대한 책임을 가져서 SRP를 위반한것처럼 보인다. 하지만 그렇다고 모뎀을 쪼갤수는 없다. 수소, 산소 원자가 단독으로 역활을 못하는것처럼 사람들이 필요한것은 통신시스템이 아니라 모뎀이기 때문이다. 이처럼 바라보는 시각에 따라 SRP를 위반했는지 지켰는지가 달라지게 된다. 통신관리, 연결관리를 ISP 원칙에 따라 인터페이스로 분리하여 재사용성을 높일수 있고 SRP를 보완하게 된다.

#### 5. 의존관계 역전원칙
구현이 아닌 인터페이스에 의존해야 한다. 자바의 리스트는 인터페이스이고 이의 구현체를
LinkedList, ArrayList등이 있다. ArrayList를 사용하고 있을때, 굳이 ArrayList가
제공하는 메소드가 필요없으면 객체 래퍼런스를 List로 받아쓰는것이 좋다. 향후
LinkedList로 교체하게되면, 구현체만 바꿔주면 클라이언트 코드의 동작이 보장된다.



## 2. 의존성주입 (Dependency Injection), 제어의 역전 (Inversion of Control)

```java

public class PlatformsService {
    private final PlatformsRepository repository = new PlatformsRepositoryMyImpl();
 }
```

위의 코드는 (역활)인터페이스 뿐만아니라 구현에 의존하고 있다 구현체를 바꿀때마다 코드를 변경해야 함으로
 개방패쇄원칙에 위배 된다. 

 ```java

public class PlatformsService {
    private final PlatformsRepository platformsRepository;

    public PlatformsService(PlatformsRepository platformsRepository) {
        this.platformsRepository = platformsRepository;
    }
 }
```
이렇게 구현객체를 인터페이스로 받게되면, 구현체를 바꾸더라도 클라이언트 코드인 PlatformsService의 변경을 막을수 있다.
PlatformsService에 구현체를 집어넣어주는 행위를 의존성주입이라고 한다.
스프링 프레임워크는 스프링 컨테이너 기술을 제공하여 어노테이션과 함께 구현체를 싱글톤으로 관리하고 외부에서 주입시켜준다. 이과정속에서 객체에 대한 관리 권한은 사용자가 아니라 프레임워크가 쥐게 되므로 이를 제어의 역전이라고 부른다.
