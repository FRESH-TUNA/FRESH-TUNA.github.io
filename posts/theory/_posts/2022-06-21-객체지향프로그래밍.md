---
layout: post
title: "객체지향 프로그래밍"
tags: [Java, Spring]
comments: true
---
## 0. 객체지향 프로그래밍
- 우리가 사는 실세계를 참고하여 객체들을 창조하고,  그 객체들 간의 협력을 통해 프로그래밍 하는 방법이다.
- 객체는 상태를 가지고 있다. 현재 상태 기반으로 책임에 맞는 행동(메소드)를 수행하여 성공/실패여부를 판단하고, 새로운 상태로 갱신한다.

## 1. 객체지향 프로그래밍의 장단점
- 코드 재사용
    + 같은 역활이 필요하면, 해당 역활을 수행하는 객체를 재사용하면 된다.

- 유지보수가 쉽다
    + 문제가 있는 객체를 수정하면 된다.

- 처리속도가 느리다.
    + 객체간의 메시지 교환을 통해 처리하기 때문이다.

## 1. 객체지향 프로그래밍의 특징
#### 1. 추상화
복잡한 대상들에서 핵심적인 특징들을 찾아내 역활(개념)들로 분류하는것이다. 
추상화에 단점은 없을까? 초기에 개발시간이 많이 걸리는 단점이 있다. (인터페이스 파일도 만들어야 되고, 디버깅할때 인터페이스 한번보고 클래스파일 찾아본다.)

#### 2. 캡슐화
협력에 필요한 메시지(요청)는 공개하고 나머지 내부 메시지나 메시지를 처리하는 메소드에 필요한 상태들을 감춘다. 상태에 대한 변경은 오르지 상태의 소유자 객체만 할수 있고 이를 통해 자율성을 얻는다. 자율성이 높아질수록 객체는 똑똑해지고 객체의 교체가 용이해지면서 유지보수가 쉬워진다. 캡슐화를 지켜서 개발하면 같은 메시지를 제공하는 객체로 교체를 하는것이 용이하다. (개방패쇄원칙) 

#### 2. 다형성
- 메시지(요청)와 메소드(요청의 처리)를 분리되어있다.
- 클라이언트는 역활(인터페이스)에만 의존한다.
- 구현이 변경되더라도 클라이언트는 영향을 받지 않으므로 유지보수에 유리하다.


## 2. SOLID (객체지향의 원칙)
#### 1. SRP: 단일 책임 원칙
클래스를 고치는 이유는 단 하나여야 한다.

```java
public PagedModel<QuestionListResponse> findAll(Pageable pageable, QuestionParams params) {
    UserIdentityField user = authenticatedFacade.toUserIdentityField();

    Page<Question> questions = repository.findAll(pageable, user, params);

    return pageAssembler.toModel(questions, listAssembler);
}
```

서비스코드를 보면 스프링 data jpa 에 의존하는 pageable과 PagedModel 에 의존하고 있다. 따라서 이 서비스코드는 비즈니스상에 변화가 생겨서 코드를 고치는것 뿐만 아니라 스프링 기술스택의 변경에 따라 코드를 고칠일이 발생하므로 SRP를 위반하고 있다.


#### 2. OCP: 개방 패쇄 원칙
확장에는 열려있으나 변경에는 닫혀야 한다.
    - 캡슐화를 안하면, 결합도가 높아져 수정시 관련 클라이언트코드를 모두 수정해야 한다.
    - 캡슐화를 하면, 결합도가 낮아져 해당 객체의 메소드만 수정하면 되서 확장에 열려 있다.

```java
public interface QuestionSearchRepository<T, ID> {
    Page<Question> findAll(Pageable pageable, UserIdentityField user, QuestionParams params);
}
```

위 코드는 문제들을 DB로부터 읽어오는 레파지토리 계층의 메소드이다. 메소드를 JPQL로 구현한 구현체를 사용하고 있다고 가정해보자.
Querydsl이라는 새로운 라이브러리를 알게되었다. 하지만 걱정이 없다. 리파지토리를 사용하는 서비스는 인터페이스에만 의존하고 있기
때문에 Querydsl을 사용하여 새로운 구현체를 구현하더라도(확장에 열림) 인터페이스에만 맞춰서 구현하연 서비스 코드의 변경을 막을수 있다. (변경에는 닫힘)



#### 3. LSP: 리스코프 치환원칙
역활을 구현할때 역활에 맞게 구현해야 한다.

```java
public interface QuestionSearchRepository<T, ID> {
    Page<Question> findAll(Pageable pageable, UserIdentityField user, QuestionParams params);
}
```

이코드를 다시 가져왔다. 위 메소드는 검색메소드이기 때문에 구현체에서 검색기능을 구현해야 한다. 이메소드가 삭제나 생성, 업데이트를
하도록 구현하면 LSP를 위반하게 된다.

#### 4. ISP: 인터페이스 분리 원칙
되로록 인터페이스를 분리하여(역활을 쪼개어) 한다.
어떤 클래스의 메시지를 테스트한다고 생각해보자, 클래스의 메시지는 다른 구현체에 요청을 할 가능성이 높고, 인터페이스를 통해 공개된 메시지를 통해 통신한다.
테스트를 위해선 메시지들을 위해 mocking이 필요한데, 인터페이스가 분리되어있지 않고 합쳐져 있다면 클래스(클라이언트)가 어떤 메시지를 필요로 하고 mocking을 
해야할지 판단하기 위해서는 메소드가 어떻게 구현되어있는지를 조사해야 하는 불편함이 있다.
또한 개발자가 퇴직하고 새로운 개발자가 퇴직했을때 인수인계가 안되면 위의 과정을 다시 반복해야 하기때문에 유지보수성이 떨어진다.

#### 5. 의존관계 역전원칙
구현이 아닌 인터페이스에 의존해야 한다. 자바의 리스트는 인터페이스이고 이의 구현체를
LinkedList, ArrayList등이 있다. ArrayList를 사용하고 있을때, 굳이 ArrayList가
제공하는 메소드가 필요없으면 객체 래퍼런스를 List로 받아쓰는것이 좋다. 향후
LinkedList로 교체하게되면, 구현체만 바꿔주면 클라이언트 코드의 동작이 보장된다.

