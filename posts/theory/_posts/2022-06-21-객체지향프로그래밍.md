---
layout: post
title: "객체지향 프로그래밍"
tags: [Java, Spring]
comments: true
---
## 0. 객체지향 프로그래밍
절차지향프로그래밍은 명령어의 목록으로 하는 기법
컴퓨터프로그램을 여러개의 독립된 개체들로 나누어서 협력시키는 기법

#### 1. 다형성
역활과 구현을 나누는 특성
클라이언트는 역활(인터페이스)에만 의존한다.
구현이 변경되더라도 클라이언트는 영향을 받지 않는다.

#### 2. 추상화
공통의 속성을 묶어서 상위 클래스(인터페이스)를 만드는것

#### 3. 캡슐화
객체에 역활에 맞는 속성, 행위를 묶는것

## 1. SOLID
#### 1. SRP: 단일 책임 원칙
한클래스는 하나의 책임을 가져야 한다. 다음 예시는 알고리즘에 대한 API를 제공하는 컨트롤러이다.
```java
@RestController
@RequiredArgsConstructor
@RequestMapping("/algorithms")
public class AlgorithmsController {
    private final AlgorithmsService algorithmsService;
    private final EntityManager em;

    @GetMapping
    public List<AlgorithmResponse> findAll() {
        QAlgorithm algorithm = QAlgorithm.algorithm;
        List<Algorithm> algorithms = return queryFactory
                .select(algorithm)
                .from(algorithm)

        List<AlgorithmResponse> responses = 
            algorithms.stream.map(a -> new AlgorithmResponse(a.name).toCollect());
            
        return responses;
    }
}
```

findAll() 메소드는 저장된 알고리즘들에 대한 정보를 반환한다. querydsl을 사용하여 잘 읽어오는것으로 보이지만
문제가 있습니다. 만약 기존의 jpql 방식으로 바꾸거나 아니면 더 좋은 라이브러리를 사용하면 어떨까. 또는 알고리즘에 
새로운 필드가 추가되면 어떨까.

컨트롤러의 코드를 바꾸는것에 그치지 않는다. 알고리즘과 관련된 정보를 또 다른 메소드에서 읽어서 쓰게 된다면 그 메소드의 
코드까지 수정이 발생하고, 수정이 많아질수록 부하가 걸리고 버그의 가능성이 높아진다.
위에 작성한 컨트롤러는 데이터를 DB에서 읽어오는것, 읽어온 알고리즘들을 responsedto로 변환하는 책임등 여러 책임을 가지고 있기
때문에 단일책임원칙을 위배한다. 

#### 2. OCP: 개방 패쇄 원칙
확장에는 열려있으나 변경에는 닫혀야 한다.

```java
public interface QuestionSearchRepository<T, ID> {
    Page<Question> findAll(Pageable pageable, UserIdentityField user, QuestionParams params);
}
```

위 코드는 문제들을 DB로부터 읽어오는 레파지토리 계층의 메소드이다. 메소드를 JPQL로 구현한 구현체를 사용하고 있다고 가정해보자.
Querydsl이라는 새로운 라이브러리를 알게되었다. 하지만 걱정이 없다. 리파지토리를 사용하는 서비스는 인터페이스에만 의존하고 있기
때문에 Querydsl을 사용하여 새로운 구현체를 구현하더라도(확장에 열림) 인터페이스에만 맞춰서 구현하연 서비스 코드의 변경을 막을수 있다. (변경에는 닫힘)


#### 3. LSP: 리스코프 치환원칙
역활을 구현할때 역활에 맞게 구현해야 한다.

```java
public interface QuestionSearchRepository<T, ID> {
    Page<Question> findAll(Pageable pageable, UserIdentityField user, QuestionParams params);
}
```

이코드를 다시 가져왔다. 위 메소드는 검색메소드이기 때문에 구현체에서 검색기능을 구현해야 한다. 이메소드가 삭제나 생성, 업데이트를
하도록 구현하면 LSP를 위반하게 된다.
#### 4. ISP: 인터페이스 분리 원칙
되로록 인터페이스들을 분리하여(역활을 쪼개어) 컴포지션하자
인터페이스를 최대한 쪼개놓고, 인터페이스가 변경되면, 이를 구현한 구현체들의 소스 변경을
최소화할수 있다.

#### 5. 의존관계 역전원칙
구현이 아닌 인터페이스에 의존해야 한다. 자바의 리스트는 인터페이스이고 이의 구현체를
LinkedList, ArrayList등이 있다. ArrayList를 사용하고 있을때, 굳이 ArrayList가
제공하는 메소드가 필요없으면 객체 래퍼런스를 List로 받아쓰는것이 좋다. 향후
LinkedList로 교체하게되면, 구현체만 바꿔주면 클라이언트 코드의 동작이 보장된다.



## 2. 의존성주입 (Dependency Injection), 제어의 역전 (Inversion of Control)

```java

public class PlatformsService {
    private final PlatformsRepository repository = new PlatformsRepositoryMyImpl();
 }
```

위의 코드는 (역활)인터페이스 뿐만아니라 구현에 의존하고 있다 구현체를 바꿀때마다 코드를 변경해야 함으로
 개방패쇄원칙에 위배 된다. 

 ```java

public class PlatformsService {
    private final PlatformsRepository platformsRepository;

    public PlatformsService(PlatformsRepository platformsRepository) {
        this.platformsRepository = platformsRepository;
    }
 }
```
이렇게 구현객체를 인터페이스로 받게되면, 구현체를 바꾸더라도 클라이언트 코드인 PlatformsService의 변경을 막을수 있다.
PlatformsService에 구현체를 집어넣어주는 행위를 의존성주입이라고 한다.
스프링 프레임워크는 스프링 컨테이너 기술을 제공하여 어노테이션과 함께 구현체를 싱글톤으로 관리하고 외부에서 주입시켜준다. 이과정속에서 객체에 대한 관리 권한은 사용자가 아니라 프레임워크가 쥐게 되므로 이를 제어의 역전이라고 부른다.
