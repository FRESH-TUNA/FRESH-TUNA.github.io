I"_<h2 id="1-프롤로그">1. 프롤로그</h2>
<p>ORM이란 프로그래밍언어상의 객체와 관계형 데이터베이스 간의 매핑을 의미한다.
RDBMS를 연동할 때, SQL이나 Stored Procedure를 사용할수 있지만 
ORM을 사용하면, 좀더 효율적으로 개발이 가능하다.</p>

<p>ORM에선 SQL문을 사용하지 않기 때문에 추상화되어 다양한 DBMS에서 돌아갈수 있는
확률이 높다. (추상화되어서 이식성이 높다.)
<br /><br /></p>

<h2 id="2-django-orm">2. Django ORM</h2>
<h3 id="시나리오-1">시나리오 1</h3>
<p>포스트들에 대헤 주어진 어트리뷰트에 대해 검색과 정렬을 처리하는 비즈니스 로직이 필요하다.
<br /><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">semester</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">queryset</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">semester__in</span><span class="o">=</span><span class="n">semester</span><span class="p">)</span>
</code></pre></div></div>
<p>만약 SELECT * FROM TABLE WHERE VALUE IN (1, 2, 3) 같은것을 처리하려면 
원하는 어트리뷰트에 __in을 붙여서 다음과 같이 구현할수 있다.
<br /><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queryset</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">professor</span><span class="o">=</span><span class="n">professorName</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">subject__contains</span><span class="o">=</span><span class="n">subject</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">id__in</span><span class="o">=</span><span class="p">[</span><span class="n">bookmark</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="nb">id</span> <span class="k">for</span> <span class="n">bookmark</span> <span class="ow">in</span> <span class="n">BookMark</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="nb">all</span><span class="p">()</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">user</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="p">)]),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">haveAnswer</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">professor</span><span class="o">=</span><span class="n">professorName</span><span class="p">),</span>
</code></pre></div></div>

<p>기존의 filter 메소드는 query 인자를 하나밖에 받지 못한다. 따라서 여러 query를 처리
하기 위해선 filter().filter().. 의 chaining를 사용해야 했다.</p>

<p>그러지말고 다음과 같이 Q를 활용하여 filter나 get연산시 복잡한 Query를 처리해보자
콤마(,)를 통해 and를 나타내고 (|)를 통하여 or를 나타낸다.
<br /><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Round</span><span class="p">(</span><span class="n">Func</span><span class="p">):</span>
    <span class="n">function</span> <span class="o">=</span> <span class="s">"ROUND"</span>
    <span class="n">template</span> <span class="o">=</span> <span class="s">"</span><span class="si">%(function)</span><span class="s">s(</span><span class="si">%(expressions)</span><span class="s">s::numeric, 1)"</span>

<span class="n">queryset</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
    <span class="n">star</span><span class="o">=</span><span class="n">Coalesce</span><span class="p">(</span><span class="n">Round</span><span class="p">(</span><span class="n">Avg</span><span class="p">(</span><span class="s">'comments__star'</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">))</span>
        
<span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">or</span> <span class="n">sort</span> <span class="o">==</span> <span class="s">'recently'</span><span class="p">:</span> 
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'-year'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span> 
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">'-star'</span><span class="p">)</span> <span class="c1">#차후에 구현한다.
</span><span class="k">return</span> <span class="n">queryset</span>
</code></pre></div></div>

<p>사용자의 요구에 따라 최근에 만들어진순이나 평점순으로 정렬하여 반환하게 하고 싶은데
만약 평점을 매긴 사람이 아무도 없다면, null이 되어 평점순으로 정렬이 안되는 문제점이 있었다.
이를 해결하기위해 Coalesce()를 사용하였다.</p>

<p>Coalesce는 리스트를 순차적으로 탐색하여 null이 안나오는 최초의 값을 반환한다.
이를 이용해 Avg()를 통해 얻은 평균값이 null이면 0.0이 반환되도록 맨들었다 호호</p>

<p>정렬의 경우 DESC로 하고 싶으면 어트리뷰트앞에 -를 붙여서 
order_by(‘-star’)와 같이 해주면 된다.</p>

:ET